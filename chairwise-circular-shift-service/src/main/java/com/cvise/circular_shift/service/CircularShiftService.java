package com.cvise.circular_shift.service;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.stream.Stream;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.cvise.circular_shift.exception.HttpFileTransferFailed;
import com.cvise.circular_shift.exception.InternalHttpRequestFailed;
import com.cvise.circular_shift.exception.NotFoundException;
import com.cvise.circular_shift.entity.KeywordsInContext;
import com.cvise.circular_shift.respository.KeywordsInContextRepository;
import com.cvise.circular_shift.respository.KeywordsInContextRepositoryCustomImpl;
import com.cvise.circular_shift.exception.FileReadException;

@Service
public class CircularShiftService {
	@Value("${user.home}")
    private String localFilesReferenceDir;

	private KeywordsInContextRepository repository;
	private KeywordsInContextRepositoryCustomImpl customRepository;
    public CircularShiftService(KeywordsInContextRepository repository,
    							KeywordsInContextRepositoryCustomImpl customRepository) {
    	this.repository = repository;
    	this.customRepository = customRepository;
    }
    
    /**Return list of string of keywords in context by id.
     * 
     * @param id 
     * @return List of string of keywords in context.
     */
    public List<String> getKeywordsById(String id) {
    	KeywordsInContext keywords = repository.findById(id).orElseThrow(NotFoundException::new);
    	return keywords.getKeywords();
    }
    
    /**Perform circular shift on a text to get list of keywords in context.
     * 
     * @param input String of input data to perform circular shift to
     * 		  create keywords in context.
     * @return List of string of keywords in context.
     */
    public List<String> getKeywordsInContextForText(String input) {
    	List<String> keywordsInContext = new ArrayList<>();
    	List<String> inputList = Arrays.asList(input.split(" "));
    	int inputListSize = inputList.size();
    	for (int i = 0; i < inputListSize; i++) {	
    		keywordsInContext.add(String.join(" ", inputList));
    		Collections.rotate(inputList, 1); 
    	}
    	return keywordsInContext;
    }
    
    /**Store keywords in context that was generated by the text input
     * into a database.
     * 
     * @param entityId String of id of entity inside the database to
     * 		  store the keyword.
     * @param input String of input data to perform circular shift to
     * 		  create keywords in context.
     */
    public void storeAllKeywordsInContextsToDatabase(String entityId, String input) {
    	List<String> keywordsInContext = getKeywordsInContextForText(input);
    	for (String keywordInContext : keywordsInContext) {
    		customRepository.pushUniqueKeywordById(entityId, keywordInContext);
    	}
    }
    
    /**Store keywords in context that was generated by the content of a text file
     * into a database, then remove the file.
     * 
     * @param path String of path to  local file of text to perform circular shift.
     * @return String of entity id for element that stored the keywords.
     */
    public String storeAllKeywordsInContextFromFileToDatabase(String path) {
    	Path localFilePath = Paths.get(path);
    	try (Stream<String> stream = Files.lines(localFilePath)) {
    		KeywordsInContext newKeywords = repository.save(new KeywordsInContext(new ArrayList<String>()));
			String keywordsId = newKeywords.getId();
			stream.forEach((line -> { storeAllKeywordsInContextsToDatabase(keywordsId, line); }));
			Files.deleteIfExists(localFilePath);
			return keywordsId;
		} catch (IOException e) {
			e.printStackTrace();
			throw new FileReadException("Could not store file "
				+ localFilePath.toString()
                + " as keywords in context into the database. Please try again!");
		}
    }
    
    /**Upload file from a URL location that was generated by
     * an API endpoint to a local location.
     * 
     * @param apiUrl String of API endpoint to make http request
     * 		  for the file location.
     * @param requestMethod String of REST verb to make the http
     * 		  request with.
     * @param contentType String of MIME of expected result from
     * 		  the http request. In this case, the MIME type should
     * 		  be "text/plain" since a String of URL of file location
     * 		  is expected from the API call.
     * @return String of path to local file 
     */
    public String uploadFileFromApiRequest(String apiUrl,
    									   String requestMethod,
    									   String contentType) {
    	String urlToDataFile = getStringFromHttpRequest(
    			apiUrl,
    			requestMethod,
    			contentType);
    	String pathToLocalFile = uploadFileFromLink(urlToDataFile);
    	return pathToLocalFile;
    }

    /**Make an http request to an URL that must respond with a String.
     * 
     * @param url String of API endpoint to make http request.
     * @param requestMethod String of REST verb to make the request with.
     * @param contentType String of MIME of expected return content type.
     * @return String response from the http request.
     */
    public String getStringFromHttpRequest(String url,
    									   String requestMethod,
    									   String contentType) {
    	try {
    		// Connect to the endpoint
    		URL urlObj= new URL(url);
        	HttpURLConnection con = (HttpURLConnection) urlObj.openConnection();
        	con.setRequestMethod(requestMethod);
        	con.setRequestProperty("Content-Type", contentType);
        	
        	// Read result from the endpoint
        	InputStream conStream = con.getInputStream();
        	BufferedReader in = new BufferedReader(new InputStreamReader(conStream));
    		String inputLine;
    		StringBuffer content = new StringBuffer();
    		while ((inputLine = in.readLine()) != null) {
    		    content.append(inputLine);
    		}
    		
    		// Clean up
    		in.close();
    		con.disconnect();
    		
    		// Get the result
    		String urlToFile = content.toString();
    		return urlToFile;    		
    	} catch (Exception e) {
            e.printStackTrace();
            throw new InternalHttpRequestFailed(
            	"Failed to make http request to " + url
            	+ " with request mehod " + requestMethod
            	+ " and content type " + contentType
            	+ ". Please try again!");
        }
    }
    
    /**Efficiently upload file from a given URL to a local location
     * by using the stream transfer function.  
     * 
     * @param url String of URL to data file.
     * @return String of path to local file 
     */
    public String uploadFileFromLink(String url) {
    	String localFileName = UUID.randomUUID().toString() + ".txt";
		String localFilePath = localFilesReferenceDir + File.separator + localFileName;
    	try {
    		// Connect to the external and local file location
    		InputStream conStream = new URL(url).openStream();
    		FileOutputStream fileOutputStream = new FileOutputStream(localFilePath);
    		
    		// Stream the file to local path
    		ReadableByteChannel readableByteChannel = Channels.newChannel(conStream);
			fileOutputStream.getChannel()
			  .transferFrom(readableByteChannel, 0, Long.MAX_VALUE);
			
			// Clean up
			fileOutputStream.close();
			
			// Return path if transfer happens properly
			return localFilePath;
		} catch (IOException e) {
			e.printStackTrace();
			throw new HttpFileTransferFailed(
	            	"Failed to download file from " + url
	            	+ " to " + localFilePath
	            	+ ". Please try again!");
		}
    }
}
